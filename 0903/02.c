/**
 *  浮点数存储
 *      10进制小数转换为2进制小数
 * 
 *      - 整数部分：
 *          - 除以2取整，逆向
 *      - 小数部分：
 *          - 乘以2取整，正向
 * 
 * 
 *      5.5 => 101.1
 *        5 => 101
 *        0.5 => 1
 * 
 * 
 *      对二进制小数进行科学计数法：101.1 = 1.011 x 2^2
 *      - 为什么被称为浮点数？ - 小数点是可以移动，所以被称为浮点数
 *      - 因为可以移动小数点，所以一定可以构建一个1~2之间的小数
 * 
 *   - IEEE 浮点数的处理方式
 *      - -1^S * M *2^E
 * 
 *      - S 表示符号位
 *      - M 表示尾数
 *      - E 表示指数
 * 
 *   对于32位的浮点数：
 *      00000000 00000000 00000000 00000000
 *      
 *      - 最高位表示符号位 1
 *      - 从次高位开始共计8位表示指数位 8
 *      - 剩余位尾数为 23
 * 
 *   
 *   以 5.5 （1.011 x 2^2）为例：
 *      符号位：0
 *      指数位：2
 *      尾数位：011
 * 
 * 
 *   计算机存储为：0 00000000 00000000000000000000000
 *  
 *      指数位可以是正数，也可以是负数
 *      一共8位，2^(8-1)-1 计算出来的值被称为偏置位 127
 *          
 *      - 想要存储值为2，则指数位应为：2+127
 *      - 想要存储值为-2，则指数位应为：-2+127
 * 
 *      - 指数位：在存储时需要加上127，在取值时需要减去127
 *      
 *      尾数位：从左向右依次写书
 * 
 *  5.5 的存储：0 10000001 01100000000000000000000
 * 
 * 
 *  特殊值：
 *      无穷: 指数位全部为1，尾数位全部为0
 *          - 根据符号位：正无穷、负无穷
 *      NaN: 指数位全部位1，尾数位大于0
 *      
*/


#include <stdio.h>


int main() {
    // 将5.5存储在内存中
    // float 占4字节，32位
    // int 占4字节，32位
    float f=5.5;
    // &f 取f的地址
    // (int *)&f 将地址转换为int类型
    // *((int *)&f) 解引用，按int方式来获取内存中的值
    // 5.5的存储格式：0 10000001 01100000000000000000000
    printf("0x%x\n", *((int *)&f)); // 0x40b00000
    printf("0x%x\n", 0b1000000101100000000000000000000); // 0x40b00000
    return 0;
}